вопрос:
в этом чате все ответы пиши на русском языке!
есть задача:
на сайте woocommerce есть товары, импортированные по api от поставщиков (шины и диски).
в каждом товаре есть картинка. картинки у товаров разные - форматы png и jpg, фон прозрачный, белый, темный, само изображение товара бывает разное - одиночный товар полностью, одиночный товар частично (например - верхняя половина шины), сдвоенный товар.
нужно сделать плагин, который будет проходить по выборке товаров и для каждого товара изменять картинку.
изменение картинки:
нужно создать два шаблона - один для шин, другой для дисков.
шаблон будет состоять из фона (его нужно сгенерировать по отдельному промпту), на фоне справа внизу логотип компании, а также будут определены места на фоне, в которые будет вставляться индивидуальная для каждого товара информация (например для шин):
- по центру или немного сдвинутая вправо основная картинка товара, которая должна быть вырезана из имеющегося изображения (шина на прозрачном фоне)
далее в нужных местах основные данные:
- бренд
- модель
- основные характеристики - ширина/высота/диаметр
- индекс нагрузки
- индекс скорости
- сезонность
- информация о шипах (либо значок либо слово Шипы)
пример загружен.
вырезание картинки товара и наполнение шаблона должно осуществляться по api  с помощью инструментов на основе ИИ.
распиши, какие есть варианты для реализации подобного функционала.
в каждом варианте поредели плюсы и минусы, а в конце подведи итог с выбором самого оптимального решения (также с учетом того, что количество товаров большое и уменьшение бюджета имеет не малую роль)

Отличная задача, Василий!
Вот подробный разбор всех возможных вариантов реализации такого функционала для WooCommerce:

ответ:
---

## Вариант 1. Полностью внешний сервис для обработки изображений (API)

### Суть:

* Вынос всей логики обработки изображений (удаление/замена фона, компоновка шаблона, наложение логотипа, текста и пр.) во внешний сервис, который предоставляет API (например, **Remove.bg API** для удаления фона, **DreamStudio (Stable Diffusion)** для генерации фона, **Canva API**, **DeepAI** и т.п.).
* Плагин WordPress отправляет нужные данные по API, получает готовое изображение и сохраняет его как картинку товара.

### Плюсы:

* Минимальная нагрузка на сервер сайта (все вычисления вне WordPress).
* Простота реализации на стороне WordPress (только API-интеграция).
* Высокое качество обработки, если правильно выбрать сервисы.

### Минусы:

* Стоимость: большинство сервисов с качественным AI – платные (и оплата часто идет за каждую картинку).
* Зависимость от внешних API: может быть ограничение на количество запросов в месяц, есть риски блокировки/изменения тарифов/ограничений.
* Могут быть задержки, если очередь на обработку большая (особенно при массовой обработке).

---

## Вариант 2. Обработка изображений локально на сервере с использованием opensource ИИ-моделей

### Суть:

* Разворачиваем на сервере opensource решения для обработки изображений:

  * Для удаления фона — **U^2-Net, Segment Anything, Rembg** и пр.
  * Для генерации фонов — **Stable Diffusion**, **DALL-E**, аналоги.
  * Для компоновки и рендеринга — **Pillow**, **OpenCV** и т.п.
* Плагин отправляет данные на локальный скрипт, который все обрабатывает.

### Плюсы:

* Нет расходов на сторонние сервисы.
* Нет лимитов по количеству обрабатываемых изображений.
* Можно полностью контролировать качество, скорость, кастомизацию.

### Минусы:

* Требует выделенного сервера с GPU (или хотя бы мощного CPU), возможно — аренды VPS.
* Сложная настройка, особенно для массовой/параллельной обработки.
* Не всегда opensource решения выдают качество на уровне топовых облачных сервисов (но это можно настраивать и дорабатывать).

---

## Вариант 3. Комбинированный подход: фоновая генерация (AI), остальное — локально

### Суть:

* Фон для шаблонов генерируется 1 раз по промпту (например, через Stable Diffusion или DALL-E, можно использовать как платные, так и opensource версии).
* Все операции по вырезанию объекта, наложению логотипа, отрисовке характеристик — делаются локально через Python-скрипты/библиотеки типа Pillow, OpenCV, FPDF (если нужно на лету делать “оверлеи”).
* Плагин общается с локальным скриптом (например, через WP REST API или напрямую через PHP exec).

### Плюсы:

* Основные затраты на AI — только генерация фона, её можно делать разово (например, для каждого шаблона).
* Вся массовая обработка (обрезка, компоновка, наложение инфо) — бесплатно и быстро на сервере.
* Легко обновлять шаблоны, логотипы, менять расположение элементов.

### Минусы:

* Сложнее, чем чисто внешний API, в плане начальной настройки.
* Требуется уметь писать/интегрировать Python-скрипты.
* Если сервер слабый, обработка может быть медленной при большом количестве товаров (но обычно такие операции достаточно легкие для обычного CPU).

---

## Вариант 4. Чисто фронтенд/браузерная обработка (WebAssembly + JS)

### Суть:

* Обработка делается на клиенте: админ или контент-менеджер заходит на страницу плагина, выбирает товары, обработка картинок происходит в браузере (например, с помощью библиотек типа **Photopea**, **rembg.js**, **fabric.js**).
* После обработки картинка загружается обратно на сайт.

### Плюсы:

* Никаких затрат на сервер или API.
* Не нужна мощность сервера.
* Можно реализовать гибкий визуальный редактор.

### Минусы:

* Не автоматизировать массовую обработку (всё руками, максимум — batch на 20-30 файлов).
* Зависит от браузера, мощности клиента.
* Неудобно при очень большом количестве товаров.

---

## Сравнительная таблица

| Вариант                                  | Автоматизация | Масштабируемость | Затраты         | Качество        | Сложность реализации |
| ---------------------------------------- | ------------- | ---------------- | --------------- | --------------- | -------------------- |
| 1. Внешний сервис API                    | 100%          | Высокая          | Средние/Высокие | Отличное        | Легкая               |
| 2. Локальная opensource обработка        | 100%          | Очень высокая    | Минимальные     | Среднее/Высокое | Сложная              |
| 3. Генерация фона AI, остальное локально | 100%          | Очень высокая    | Низкие          | Хорошее         | Средняя              |
| 4. В браузере (WebAssembly)              | Ручная        | Плохая           | Нет             | Хорошее         | Средняя              |

---

## Итог: **Лучший вариант**

### Для крупного проекта с большой номенклатурой и ограниченным бюджетом — **Оптимально использовать Вариант 3**:

* **Фон** для шаблона (один раз!) генерируется через внешний AI (Stable Diffusion/DALL-E — можно даже через бесплатные ресурсы или локальный Stable Diffusion).
* **Вся остальная обработка** (вырезание товара, наложение логотипа, вставка текста, сохранение финального изображения) делается через скрипты на сервере — это быстро, бесплатно, легко автоматизировать и масштабировать.
* Нет ограничений на количество изображений, нет абонентской платы за API, нет риска попасть на большие счета.
* По качеству — достигается отличный результат, т.к. основные “AI-затраты” идут на генерацию красивого фона, а вырезание объектов и наложение текста/логотипа можно сделать с помощью хороших открытых библиотек.

**Рекомендация:**
Реализовать плагин, который по крону или по выборке товаров отправляет данные локальному скрипту (или через WP REST API), а скрипт делает всю обработку по шаблону и сохраняет новую картинку к товару.

Если нужно, помогу с примером архитектуры плагина и/или написать прототип скрипта для обработки картинок!

---

Если нужна расшифровка, примеры кода, подбор библиотек или алгоритм — пиши, дам максимально подробный гайд.


вопрос:
распиши подробнее Вариант 3
какие библиотеки лучше использовать, есть ли альтернатива скриптам pyton?
составь архитектуру плагина

ответ:
Конечно, расписываю Вариант 3 подробно, с учетом современных инструментов и оптимизации под массовую обработку товаров.

---

## **Вариант 3: Генерация фона AI, обработка изображений и компоновка — локально**

### **Общая идея**

* Фон для шаблонов (отдельно для шин и отдельно для дисков) генерируется заранее с помощью нейросети (например, Stable Diffusion).
  Фон меняется редко, его можно получить хоть в ручном режиме и хранить в плагине как ресурс.
* Далее всё работает автоматизированно:

  * Плагин получает выборку товаров (например, по крону, по кнопке в админке или по событию).
  * Для каждого товара:

    * Выделяется объект (шина/диск) из исходной картинки (AI-выделение).
    * Основное изображение помещается на заранее подготовленный шаблон.
    * В нужные зоны шаблона добавляется текст: бренд, модель, характеристики и пр.
    * В угол накладывается логотип компании.
    * Итоговое изображение сохраняется к товару (замена/добавление к галерее).

---

## **1. Библиотеки и инструменты**

### **Для выделения объекта (удаления фона):**

* **Python:**

  * [`rembg`](https://github.com/danielgatis/rembg) — быстро, качественно, удобно; есть CLI и Python API.
  * [`U^2-Net`](https://github.com/xuebinqin/U-2-Net) — основа для многих open-source решений.
* **PHP:**

  * Нормальных AI-решений для вырезания на PHP нет, только через обёртку для Python/CLI, либо через внешние API.

### **Для компоновки изображения (наложение объекта на фон, добавление текста, логотипа):**

* **Python:**

  * [`Pillow`](https://python-pillow.org/) — стандарт для обработки изображений.
  * [`OpenCV`](https://opencv.org/) — можно использовать для продвинутых эффектов.
* **PHP:**

  * [`Imagick`](https://www.php.net/manual/ru/book.imagick.php) — если нужно работать исключительно в PHP (но все продвинутые AI-фичи будут недоступны).
  * [`GD`]() — стандартная, но очень базовая (не рекомендую).

### **Генерация фона:**

* Любая нейросеть типа **Stable Diffusion** (можно через [InvokeAI](https://github.com/invoke-ai/InvokeAI), [ComfyUI](https://github.com/comfyanonymous/ComfyUI), [Automatic1111](https://github.com/AUTOMATIC1111/stable-diffusion-webui)), либо онлайн-сервис (разово).

### **Связь WordPress и Python:**

* **REST API:**
  Плагин отправляет запрос локальному скрипту через HTTP (лучше всего для масштабируемости).
* **CLI:**
  Плагин вызывает обработку через `exec()` (можно, если сервер “свой”).
* **Внешние очереди:**
  Если обрабатывать очень много, можно очередь строить через Redis, RabbitMQ и пр.

---

## **2. Альтернативы Python**

* На чистом PHP можно сделать только компоновку (Pillow-аналоги: Imagick, GD), а вот ИИ-вырезание — только через внешние сервисы или интеграцию с Python.
* Node.js:
  Есть проекты для AI-обработки изображений, но для вырезания объектов — тоже всё “упирается” в Python-решения или вызов через child process.
* Bash/CLI:
  Можно “собирать” пайплайны обработки через вызовы Python-скриптов.

**Вывод:**
Для качественного вырезания товара и быстрой компоновки лучше всего использовать связку **WordPress (PHP) + Python (rembg + Pillow)**.

---

## **3. Архитектура плагина**

### **A. Компоненты**

1. **Плагин WordPress (PHP):**

   * Настройки плагина (фон, логотип, позиции для инфоблоков, шаблон вывода, расписание кронов).
   * UI для запуска обработки (выборка товаров, запуск обработки вручную, просмотр логов).
   * Крон/автоматизация: обработка пачек товаров по расписанию.
   * Логика отправки задания на обработку (REST-запрос к Python-сервису или вызов CLI).

2. **Python-сервис обработки изображений:**

   * Принимает задание от плагина (ID товара, путь к оригиналу, параметры, текстовые данные).
   * Вырезает объект с помощью rembg/U2Net.
   * Композитит картинку на фон (Pillow): вставляет объект, логотип, текст.
   * Сохраняет итоговый файл (можно возвращать путь/URL обратно в WP).
   * (Опционально: логирование ошибок, отправка статуса обратно в WP).

3. **(Опционально) Микросервис очередей:**

   * Если объемы большие, можно организовать очередь обработки (например, через Redis или простую файловую очередь).

---

### **B. Схема архитектуры**

```plaintext
+----------------------------------+
|     WordPress Plugin (PHP)       |
|                                  |
|  - UI настройки                  |
|  - Запуск обработки товаров      |
|  - Сбор инфо о товарах           |
|  - REST-запрос к Python сервису  |
+-----------------+----------------+
                  |
                  v
+-----------------+----------------+
|   Python Image Processing API     |
|                                  |
|  - Вырезание объекта (rembg)     |
|  - Компоновка шаблона (Pillow)   |
|  - Наложение текста, логотипа    |
|  - Отправка результата обратно   |
+-----------------+----------------+
                  |
                  v
+-----------------+----------------+
|     WooCommerce/WordPress        |
|    - Обновление картинки товара  |
|    - Хранение результата         |
+----------------------------------+
```

---

### **C. Пример рабочего процесса**

1. Админ выбирает товары в плагине и нажимает “Обработать” (или по крону выбирается пачка товаров).
2. Плагин получает для каждого товара:

   * оригинальную картинку
   * необходимые данные (бренд, модель и т.д.)
3. Плагин отправляет данные в Python (REST API).
4. Python скрипт вырезает товар, накладывает на фон, добавляет логотип и текст, сохраняет финальную картинку.
5. Плагин получает обратно URL/путь к файлу и обновляет картинку товара в WooCommerce.

---

## **4. Конкретные библиотеки/стек**

* **rembg** (Python) — быстрое и бесплатное удаление фона.
* **Pillow** (Python) — работа с изображениями, компоновка, рендер текста, наложение логотипа.
* **Requests** (Python) или **Flask/FastAPI** — для создания API.
* **WP REST API** (PHP) — для связи WordPress с Python.

---

## **5. Плюсы такой архитектуры:**

* Открытое ПО — нет лишних расходов, кроме единого разового генерации фонов.
* Высокая автоматизация — полностью бесконтактный режим.
* Масштабируемость — легко увеличить мощность, если нужно.
* Гибкость — можно менять шаблоны, стили текста, расположение элементов.

---

## **6. Альтернативный, но менее гибкий вариант**

* Всё делать через внешние сервисы (remove.bg, Canva, Figma API и пр.), но платить за каждый запрос.
* PHP + Imagick, если только компоновка без AI-вырезания.

---

**Если интересно, могу расписать:**

* пример структуры плагина (PHP),
* пример вызова Python API с WP,
* пример Python-скрипта для обработки одной картинки по шаблону.

Пиши, что интересно больше всего — и распишу с кодом!


вопрос:
где должны разворачиваться pyton библиотеки и какие требования к хостингу?

ответ:
Очень важный и практичный вопрос!
Вот ответы, максимально по делу и с акцентом на реальность для WooCommerce.

---

## **Где должны разворачиваться Python-библиотеки**

### **1. На том же сервере, где размещён сайт (WordPress/WooCommerce)**

**Идеальный вариант:**

* Сервер (VPS, VDS, выделенный сервер) с доступом по SSH, где можно поставить Python, нужные библиотеки (rembg, Pillow и т.д.), и где сайт имеет возможность запускать сторонние процессы (через exec или через HTTP/REST API).

**Схема:**

* Папка с Python-скриптами (например, /srv/image\_processor/).
* Flask/FastAPI-сервис, запускаемый как демона, слушает REST-запросы только с localhost (или с нужных IP).
* PHP-плагин обращается к этому сервису через curl/http.

**Преимущества:**

* Нет затрат на передачу файлов/картинок “внешне”.
* Нет задержек между сервисами.
* Максимально простая интеграция и автоматизация.

---

### **2. На отдельном сервере/виртуалке/облачном сервисе**

**Кому подойдет:**

* Если основной хостинг — shared (обычный виртуальный хостинг, где нет root-доступа).
* Если сервер с сайтом слабый или “закрыт” для сторонних процессов.
* Если есть отдельная мощная машина (или облако) для обработки (например, сервер с GPU).

**Схема:**

* Python API работает на отдельном сервере.
* Сайт (WordPress) обращается к нему по REST API (можно даже по внутренней сети, если сервера в одном дата-центре).
* Файлы картинок пересылаются либо по сети (HTTP-запросами), либо через S3/FTP, либо по ссылке с временным доступом.

**Преимущества:**

* Можно ставить любое ПО, обновлять по своему усмотрению.
* Не влияет на производительность сайта (нагрузка вся уходит “в сторону”).

---

### **3. На локальном ПК (разработка, тестирование, ручная обработка)**

**Для тестов** можно развернуть всё локально — но для работы с продакшеном это не подходит.

---

## **Требования к хостингу**

### **Минимальные требования:**

#### **A. Shared-хостинг (виртуальный, без SSH-доступа):**

* НЕ подходит для запуска Python-скриптов и установки библиотек.
* Можно использовать только если вы всё делаете через внешний сервис обработки.

#### **B. VPS/VDS или выделенный сервер:**

* Подходит идеально.
* Должен быть установлен Python 3.8+ (лучше 3.10+).
* Должна быть возможность устанавливать пакеты через pip (rembg, Pillow, flask и т.д.).
* Желательно хотя бы 2 ГБ RAM, CPU — чем больше, тем лучше.
* Доступ по SSH для установки и поддержки.
* В случае массовой обработки — желательно наличие swap или даже GPU (если будете использовать что-то тяжелее для фонов или хотели бы развивать сервис).

#### **C. Cloud (DigitalOcean, Yandex.Cloud, AWS и пр.):**

* Всё то же самое, плюс можно поднять отдельный контейнер/инстанс для обработки изображений.

---

## **Сводная таблица**

| Тип хостинга      | Можно ли ставить Python? | Можно ли интегрировать обработку?  | Пример использования           |
| ----------------- | ------------------------ | ---------------------------------- | ------------------------------ |
| Shared (вирт.)    | Нет                      | Нет (только через внешние сервисы) | Просто сайт, вся обработка вне |
| VPS/VDS           | Да                       | Да                                 | Самый гибкий, лучшее решение   |
| Выделенный сервер | Да                       | Да                                 | Максимум производительности    |
| Облако            | Да                       | Да                                 | Удобно для масштабирования     |
| Локальный ПК      | Да                       | Только для теста                   | Для разработки                 |

---

## **Требования по ПО**

* **Python** 3.8 и выше (лучше свежее)
* **pip** для установки пакетов
* Пакеты: `rembg`, `Pillow`, (опционально `Flask`, `FastAPI`)
* Для сервисной работы — любой supervisor/pm2/systemd для запуска API-демона
* Доступ по сети между WP и сервисом обработки

---

## **Особенности безопасности**

* Не стоит открывать REST-сервис Python “на весь интернет” — только с localhost или внутренней сети, либо авторизовать запросы (через токены/API-ключи).
* Не хранить секреты/пароли открыто.

---

### **Вывод:**

* Самый оптимальный вариант — VPS/VDS (или выделенный сервер), где развёрнут WordPress и Python-сервис для обработки изображений.
* Если это невозможно — обработку выносить на отдельный сервер/облако, а сайт общается с ним по API.

---

**Если нужен пример docker-compose для запуска сервиса или совет по выбору конкретного тарифа/хостера — пиши!**


вопрос:
сайт на хостинге reg.ru, тариф VIP-2, включение pyton 3.9 доступно в панели хостинга ispmanager, доступ по ssh есть, но не root (без управления сервером)
такой сетап подойдет?

ответ:
Да, такой сетап **подойдёт**, но с некоторыми нюансами, которые нужно учитывать. Распишу подробно, что возможно, какие ограничения есть на подобных тарифах, и на что обратить внимание.

---

## **Что есть на тарифе VIP-2 reg.ru с ISPmanager и Python 3.10**

* **Доступ по SSH (без root):**
  Это не VPS, а “расширенный” shared-хостинг.
  Вы можете запускать свои процессы, устанавливать Python-библиотеки локально в user-space (через `pip install --user`), создавать виртуальные окружения.
* **Возможность запускать Python 3.10:**
  Это отлично для скриптов, мелких веб-приложений.
* **ISPmanager:**
  Позволяет включать Python, возможно создавать отдельные Python-сайты.

---

## **Что можно сделать на таком тарифе**

### **1. Установить нужные Python-библиотеки:**

* Можно установить **rembg** (`pip install --user rembg`), **Pillow**, **Flask** и все остальное.
* Можно создать виртуальное окружение Python в домашней директории пользователя.

### **2. Запускать свои скрипты вручную через SSH:**

* Любые обработки, генерации — без проблем, если запускать их “ручками” или через cron.

### **3. Поднять локальный Flask/FastAPI сервис:**

* Можно запустить Python-приложение, слушающее локальный порт (например, через `python app.py` или через WSGI).
* На хостингах такого типа часто запрещено запускать процессы “демонами” на постоянку (сервисы типа systemd/pm2/supervisor недоступны).
* Но можно запускать фоновый процесс, пока вы в сессии SSH или через cron.

### **4. Использовать cron:**

* Можно добавить задание в планировщик cron для периодической обработки товаров (например, раз в час, раз в день).

---

## **Ограничения и нюансы shared-хостинга (VIP-2)**

1. **Нет постоянных фоновых процессов:**

   * Flask/FastAPI API нельзя держать 24/7 как демона (сервис могут “убить” или он отключится после выхода из SSH).
   * Можно запускать обработку по cron или вручную.

2. **Ограничены ресурсы:**

   * Оперативная память и CPU не выделены жёстко.
   * Если запускать массовую обработку тысяч товаров — будет медленно, возможны “киллы” по лимиту времени/ресурсов.

3. **Нет root-доступа:**

   * Нельзя установить системные пакеты или обновить глобальный Python.
   * Можно только “в своём” окружении.

4. **Доступ к портам ограничен:**

   * Обычно только порты для сайтов (80, 443), любые “левые” порты могут быть недоступны извне.
   * Можно поднимать скрипты, которые слушают localhost.

---

## **Реалистичная архитектура на таком хостинге**

**1. Основной вариант:**

* Плагин WordPress “ставит” задачи на обработку (например, кладёт JSON с задачами в определённую папку).
* Python-скрипт по cron (раз в 5-10 минут) проверяет эту папку, обрабатывает задачи, кладёт результат (новое изображение) в нужную директорию.
* Плагин периодически проверяет, появились ли готовые картинки, и обновляет изображения товаров.

**2. Вариант с ручным запуском:**

* Всё то же самое, но обработку запускаете по SSH командой вручную.

**3. Если хочется REST API:**

* Можно поднять Flask/FastAPI на временный порт, но только для локальных запросов и только пока сессия активна (не production-ready).
* На практике, надёжнее работать через файловые очереди и cron.

---

## **Рекомендация**

* Для ваших задач такой тариф **подходит** для теста, прототипа и даже небольших объёмов (до нескольких сотен товаров в сутки).
* Для больших объёмов/автоматизации — либо переходите на VPS (там можно держать постоянные сервисы), либо делайте интеграцию через cron.
* Лучше не полагаться на “вечные” Python-сервисы на shared-хостинге: обработку делать по расписанию или при ручном запуске.

---

### **Вывод:**

* **Ваш тариф подходит для запуска Python-скриптов, установки библиотек и обработки картинок!**
* **Лучший способ автоматизации — использовать cron:**
  Запланировать выполнение Python-скрипта с определённой периодичностью (например, каждую ночь обрабатывать новые товары).
* **Flask/FastAPI API-сервисы запускать на shared-хостинге можно только временно, не надейтесь на постоянную доступность.**

---

**Если нужно — скину пример кода для интеграции через cron или объясню, как построить очередь задач для такой схемы!**
Если есть вопросы по настройке pip, venv или cron — пиши, подскажу, как правильно настроить на вашем тарифе.


вопрос:
ты - опытный промпт-инженер.
составь инструкции для OpenAi (будет использован редактор Cursor и модель gpt-4.1) по созданию плагина и скриптов обработки изображений для реализации Варианта 3: Генерация фона AI, обработка изображений и компоновка — локально.
где-то в начале должны быть общие указания, которыми модель OpenAi должна руководствоваться на протяжении всего проекта и которые не нужно будет дублировать в каждом сообщении чата. Пример (нужно переработать конкретно для данного проекта):
## Общие принципы работы
1. Все изменения должны быть обратно совместимы
2. Каждое изменение должно включать механизм отката
3. Все действия должны логироваться
4. Система должна быть устойчива к сбоям

## Обязательные проверки перед внесением изменений
1. Анализ структуры проекта:
   - Запросить полную структуру через list_dir
   - Проверить все взаимосвязанные файлы
   - Изучить зависимости от WordPress и других плагинов

2. Проверка конфигурации:
   - Настройки сервера
   - Конфигурация WordPress
   - Настройки Action Scheduler
   - Параметры кэширования

3. Анализ текущего состояния:
   - Активные задачи
   - Временные данные
   - Очередь задач
   - Логи ошибок

## Приоритеты при разработке
1. Надежность:
   - Проверка всех входных данных
   - Обработка всех возможных ошибок
   - Восстановление после сбоев
   - Защита от race conditions

2. Производительность:
   - Оптимизация запросов к БД
   - Эффективное использование кэша
   - Контроль использования памяти
   - Оптимальный размер батчей

3. Безопасность:
   - Проверка прав доступа
   - Валидация всех входных данных
   - Защита от SQL-инъекций
   - Безопасное хранение данных

## Правила работы с задачами
1. Создание задачи:
   - Генерация уникального task_id
   - Сохранение всех параметров
   - Установка времени начала
   - Логирование создания

2. Обработка задачи:
   - Проверка валидности
   - Обновление времени активности
   - Обработка ошибок
   - Логирование прогресса

3. Завершение задачи:
   - Проверка результатов
   - Очистка временных данных
   - Обновление статистики
   - Логирование завершения

## Требования к коду
1. Структура:
   - Модульность
   - Повторное использование
   - Читаемость
   - Документированность

2. Обработка ошибок:
   - Try-catch блоки
   - Проверка возвращаемых значений
   - Логирование ошибок
   - Механизмы восстановления

3. Оптимизация:
   - Кэширование
   - Индексация
   - Оптимизация запросов
   - Контроль памяти

## Мониторинг и диагностика
1. Логирование:
   - Все критические операции
   - Ошибки и исключения
   - Время выполнения
   - Использование ресурсов

2. Диагностика:
   - Проверка состояния системы
   - Мониторинг производительности
   - Отслеживание ошибок
   - Анализ логов

## Механизмы восстановления
1. Автоматические:
   - Восстановление зависших задач
   - Очистка устаревших данных
   - Перезапуск после сбоев
   - Синхронизация состояния

2. Ручные:
   - Сброс временных данных
   - Очистка очереди задач
   - Восстановление из бэкапа
   - Ручной перезапуск

## Документирование изменений
1. Для каждого изменения:
   - Описание проблемы
   - Принятое решение
   - Внесенные изменения
   - Тестирование

2. В коде:
   - Комментарии к функциям
   - Описание параметров
   - Примеры использования
   - Примечания по безопасности
   
# Стандарты кодирования WordPress

## Общие правила
1. Стиль кода:
   - Отступы: табуляция (не пробелы)
   - Длина строки: не более 80 символов
   - Кодировка файлов: UTF-8 без BOM
   - Символ конца строки: LF (\n)

2. Именование:
   - Классы: PascalCase (Product_AI_Generator)
   - Функции: snake_case (product_ai_generate_batch)
   - Переменные: snake_case ($batch_size)
   - Константы: UPPER_CASE (PRODUCT_AI_VERSION)
   - Префиксы: product_ai_ для всех функций и классов

3. Документирование:
   - PHPDoc для всех функций и классов
   - Описание параметров и возвращаемых значений
   - Примеры использования
   - Примечания по безопасности

## Структура кода
1. Файлы:
   - Один класс/интерфейс на файл
   - Имя файла соответствует имени класса
   - Расширение .php
   - Заголовок с описанием плагина

2. Классы:
   - Наследование от WP_* классов
   - Реализация интерфейсов WordPress
   - Использование трейтов при необходимости
   - Приватные методы для внутренней логики

3. Функции:
   - Единая ответственность
   - Максимум 50 строк
   - Проверка входных данных
   - Обработка ошибок

## WordPress API
1. Хуки:
   - Использование add_action/add_filter
   - Приоритеты: 10 по умолчанию
   - Документирование параметров
   - Проверка существования хуков

2. База данных:
   - Использование $wpdb
   - Подготовленные запросы
   - Экранирование данных
   - Оптимизация запросов

3. Опции:
   - Использование get_option/update_option
   - Префикс для всех опций
   - Автозагрузка только критичных опций
   - Очистка при деактивации

## Безопасность
1. Данные:
   - Валидация всех входных данных
   - Экранирование вывода
   - Проверка nonce
   - Проверка прав доступа

2. Запросы:
   - Подготовленные запросы
   - Экранирование SQL
   - Проверка типов данных
   - Логирование ошибок

3. Файлы:
   - Проверка MIME-типов
   - Валидация путей
   - Безопасные права доступа
   - Логирование операций

## Производительность
1. Запросы:
   - Кэширование результатов
   - Оптимизация JOIN
   - Индексация таблиц
   - Контроль количества запросов

2. Память:
   - Очистка временных данных
   - Контроль размера батчей
   - Освобождение ресурсов
   - Мониторинг использования

3. Кэширование:
   - Использование transients
   - Кэширование запросов
   - Очистка кэша
   - Контроль времени жизни

## Тестирование
1. Модульные тесты:
   - Использование PHPUnit
   - Тестирование всех функций
   - Моки для внешних зависимостей
   - Проверка граничных случаев

2. Интеграционные тесты:
   - Тестирование с WordPress
   - Проверка совместимости
   - Тестирование производительности
   - Проверка безопасности

3. Отладка:
   - Использование WP_DEBUG
   - Логирование ошибок
   - Трассировка выполнения
   - Профилирование кода
Также должна быть поставлена общая цель, которой нужно достигнуть в результате разработки инструментов. Составлен план, а затем подробные инструкции для каждой части плана. Подробные инструкции должны включать конкретные способы, методы, приемы и т.д. для написания полностью рабочего кода плагина wordpress/woocommerce, а также скриптов python.
если я что-то упустил  - добавь сам.

ответ:
Василий, вот **структурированная инструкция для OpenAI (модель GPT-4.1 в редакторе Cursor)** для проекта “AI-обработка изображений товаров для WooCommerce”:
Документ предназначен для полного цикла разработки — от архитектуры до кода и тестирования. Учитываются твои задачи, лучшие практики WordPress и особенности автоматизации на shared/VIP-хостинге.

---

# **Общие указания (соблюдать на всех этапах проекта)**

## **1. Архитектурные принципы**

* Все компоненты должны быть **модульными** и легко расширяемыми.
* Предпочтение решениям, которые легко автоматизировать и поддерживать.
* Плагин WordPress и Python-скрипты — физически раздельные, взаимодействуют только через файловую систему и/или HTTP.

## **2. Надёжность и отказоустойчивость**

* Каждый этап (создание задания, обработка, получение результата) логируется.
* Предусмотреть механизм повторных попыток при сбоях.
* Каждое задание должно иметь уникальный ID и статус (создано/в обработке/готово/ошибка).
* Система устойчива к зависаниям и частичному выполнению.

## **3. Безопасность**

* Все входные данные валидируются и логируются.
* Взаимодействие между компонентами только в пределах доверенной инфраструктуры.
* Обеспечить безопасную работу с файлами: проверка расширения, MIME-типов, контроль прав.

## **4. Производительность**

* Пакетная обработка (batch): не более N товаров за раз (N настраивается).
* Минимизировать операции с БД и файловой системой.
* Лимитировать размер изображений и их число в одной задаче.

## **5. Совместимость**

* Код плагина совместим с последними версиями WordPress и WooCommerce, использует стандарты WordPress.
* Python-скрипты совместимы с Python 3.10+.

## **6. Документирование**

* Любое изменение сопровождается описанием цели, внесённых изменений и тестовым сценарием.
* Код документирован (PHPDoc для PHP, docstring для Python).

## **7. Резервное копирование и восстановление**

* Хранить исходные изображения и промежуточные файлы до успешного завершения задачи.
* Предусмотреть возможность ручного или автоматического восстановления при сбоях.

---

# **Общая цель проекта**

**Создать полностью автоматизированную и расширяемую систему для генерации и подмены изображений товаров в WooCommerce с помощью AI, состоящую из WordPress-плагина и Python-скриптов.
Система должна:**

* Формировать шаблонные изображения товаров с выделением объекта, фирменным фоном и текстовыми метками.
* Массово и автоматически обрабатывать большие выборки товаров.
* Позволять управлять процессом из админки WordPress.
* Быть легко разворачиваемой и поддерживаемой на ограниченном хостинге.

---

# **План реализации**

1. **Проектирование и разметка API/файлового интерфейса между WordPress и Python.**
2. **Разработка WordPress-плагина:**

   * UI, создание и управление задачами, интеграция с очередью и cron.
3. **Разработка Python-скриптов:**

   * Получение задания, обработка изображения, возврат результата и логирование.
4. **Интеграция, тестирование и оптимизация.**
5. **Документирование всех этапов, инструкций по установке и эксплуатации.**

---

# **Подробные инструкции для каждого этапа**

## **1. Проектирование интерфейса взаимодействия**

* Выбрать способ обмена заданиями: файловый обмен (`tasks/` и `results/` папки) или REST API (если хостинг позволяет).
* Формат задачи: JSON с уникальным ID, ссылкой на оригинальное изображение, структурой данных (бренд, модель, характеристики).
* Формат результата: JSON c ID, статусом, ссылкой на итоговое изображение/ошибкой.
* Все файлы в очереди должны подписываться датой/ID, не перезаписываться.

## **2. WordPress-плагин (PHP)**

### **2.1 Структура**

* Оформить как полноценный плагин с мета-информацией.
* Следовать WordPress Coding Standards (см. подробные правила выше).
* Все публичные функции/классы — с префиксом plugin\_ai\_.

### **2.2 UI и управление**

* Страница управления задачами: выборка товаров, запуск задачи, просмотр логов и статусов.
* Настройки: размер батча, пути к папкам tasks/results, параметры обработки (шаблоны, лого, фон).

### **2.3 Работа с заданиями**

* Создание задания на обработку:

  * Генерировать уникальный ID.
  * Собрать все данные товара, подготовить JSON и положить в папку tasks/.
  * При необходимости — копировать оригинальную картинку в temp/ (или давать ссылку).
* Контроль выполнения:

  * Проверять наличие результата по ID (из папки results/).
  * В случае ошибки — логировать, уведомлять.
  * В случае успеха — подменять изображение товара, сохранять оригинал.
* Поддерживать выполнение через cron и вручную из админки.

### **2.4 Логирование**

* Все этапы работы логируются с уровнем (info/warning/error).
* Вести отдельный лог-поток по каждому заданию.

### **2.5 Безопасность**

* Все пути и операции с файлами — только в пределах wp-content/uploads/plugin\_ai/ (никаких абсолютных путей!).
* Все пользовательские действия — с проверкой nonce и прав.

### **2.6 Резервное копирование**

* Оригинальные картинки — сохранять до подтверждения успешной обработки.
* Временные данные очищать по расписанию/по завершении.

---

## **3. Python-скрипты**

### **3.1 Структура и окружение**

* Python 3.10+, использовать venv.
* requirements.txt с зависимостями: rembg, pillow, jsonschema, logging.
* Главный скрипт: ai\_image\_processor.py

### **3.2 Основные функции**

* Регулярно сканировать папку tasks/ на новые задания.
* Для каждого задания:

  * Валидировать входные данные (JSON schema).
  * Скачать/открыть оригинальное изображение.
  * Вырезать объект (rembg).
  * Наложить на шаблонный фон (подгружается из папки templates/).
  * Вставить лого и текстовые поля (характеристики) с помощью Pillow.
  * Сохранить итоговое изображение в results/, сформировать JSON-ответ.
  * Все этапы логировать.

### **3.3 Отказоустойчивость**

* Любые ошибки — писать в отдельный error-log и в JSON-ответ.
* Пропускать “битые” задания, не блокируя очередь.
* Старые или некорректные задания — перемещать в архив/отдельную папку.

### **3.4 Масштабирование**

* Все параметры (размеры, шаблоны, расположение текста) — через config.yaml.
* Поддержка нескольких типов шаблонов (для шин и дисков).

---

## **4. Интеграция и тестирование**

* Сначала настроить обмен файлами на тестовом окружении (раз в 5-10 минут cron-скрипт).
* Провести обработку партии товаров, проверить корректность логирования, отката, очистки.
* Написать интеграционные тесты для основных сценариев (через WP-CLI и shell-скрипты).
* Все изменения документировать с указанием цели и результата.

---

## **5. Документирование и эксплуатация**

* Описать процесс установки (PHP и Python-часть отдельно).
* Описать процесс настройки и эксплуатации, механизм восстановления при сбоях.
* Приложить примеры типовых конфигов, логов и шаблонов.

---

# **Способы и методы для кода (конкретика)**

## **WordPress (PHP)**

* Для очереди задач использовать файловую систему (`wp-content/uploads/plugin_ai/tasks/`).
* Для запуска обработки — планировщик cron (wp\_cron или системный cron через exec).
* Для подмены изображений использовать стандартные функции WP (wp\_update\_attachment\_metadata).
* Для логирования — отдельный файл или опция в базе, ограничивать размер лога.
* Для UI — использовать стандартный WP List Table для задач, секции для логов и настроек.
* Для взаимодействия с Python — только файлы, либо локальный HTTP (если сервер позволяет).
* Проверять права пользователей (manage\_options для админки).

## **Python**

* Для удаления фона — rembg (Python API, локально, без интернет-запросов).
* Для обработки изображений — Pillow (открытие, наложение, рендер текста, работа с прозрачностью).
* Для настройки — config.yaml (PyYAML), параметры путей, шаблонов, размера батча.
* Для логирования — стандартный logging (ротация файлов, отдельный log для ошибок).
* Для запуска — системный cron (или вручную из SSH).
* Для обмена — один JSON-файл на задачу, ID = уникальный хеш/UUID.

---

# **Добавить:**

* В описаниях классов/функций указывать, на какой части пайплайна находится данный элемент (например: “Task Handler”, “Image Composer”).
* При наличии неочевидных моментов — всегда оставлять комментарии с пояснением логики, а также описывать способы расширения (например, как добавить новый шаблон).

---

## \*\*Если нужен шаблон файла с этими инструкциями для Cursor — готов дать готовый markdown.

Если нужно расписать структуру директорий или пример структуры очереди — тоже могу.\*\*

Если есть пожелания к более “жёстким” требованиям — укажи!


вопрос:
нужно расписать структуру директорий и пример структуры очереди.
также нужен шаблон файла с этими инструкциями для Cursor.

ответ:
Вот максимально практичная и удобная структура директорий, пример структуры очереди для обмена заданиями между WordPress и Python-скриптами, а также markdown-шаблон файла инструкций для Cursor (с оформлением, чтобы всегда был под рукой весь регламент).

---

## 1. **Структура директорий проекта**

Вариант рассчитан на реальное развертывание на хостинге (например, reg.ru VIP-2, wp-content/uploads), всё должно быть изолировано внутри папки плагина.

```plaintext
wp-content/
└── uploads/
    └── ai_image/
        ├── tasks/           # Задания на обработку (создаёт WP-плагин)
        ├── results/         # Готовые результаты (кладёт Python)
        ├── originals/       # Оригиналы изображений товаров (копия)
        ├── processed/       # Готовые итоговые картинки
        ├── temp/            # Временные файлы (ресайзы, конвертация и пр.)
        ├── templates/       # Фоновые шаблоны для шин и дисков (PNG, JPG)
        ├── logos/           # Логотипы компании (PNG, SVG)
        ├── logs/            # Логи работы WP и Python частей
        ├── archive/         # Старые задания и результаты (хранятся X дней)
        ├── config/          # Конфиги (config.yaml для Python, .json для плагина)
        └── readme.md        # Техническая документация по структуре и использованию
```

**Примечания:**

* Все относительные пути должны строиться от `wp-content/uploads/ai_image/`.
* Для WP-плагина — никаких файлов за пределами uploads.
* Права доступа: только для веб-сервера и владельца аккаунта.

---

## 2. **Пример структуры очереди (задания)**

### **a) Формат задания (tasks/):**

**Файл:**
`tasks/20240610T153000_abc12345.json`

**Пример содержимого:**

```json
{
  "task_id": "20240610T153000_abc12345",
  "type": "tyre",  // или "disk"
  "original_image": "originals/tyre_123456.png",
  "template": "templates/tyre_template_v2.png",
  "logo": "logos/company_logo.png",
  "product_data": {
    "brand": "Michelin",
    "model": "X-Ice North 4",
    "width": "205",
    "height": "55",
    "diameter": "R16",
    "load_index": "94",
    "speed_index": "T",
    "season": "зима",
    "studded": true
  },
  "output_filename": "processed/tyre_123456_ai.png",
  "created_at": "2024-06-10T15:30:00+03:00"
}
```

### **b) Формат результата (results/):**

**Файл:**
`results/20240610T153000_abc12345.json`

**Пример содержимого:**

```json
{
  "task_id": "20240610T153000_abc12345",
  "status": "success", // или "error"
  "output_image": "processed/tyre_123456_ai.png",
  "log": "logs/20240610T153000_abc12345.log",
  "message": "OK",
  "started_at": "2024-06-10T15:31:00+03:00",
  "finished_at": "2024-06-10T15:31:20+03:00",
  "error": null
}
```

**Если ошибка:**

```json
{
  "task_id": "20240610T153000_abc12345",
  "status": "error",
  "output_image": null,
  "log": "logs/20240610T153000_abc12345.log",
  "message": "Ошибка обработки изображения: rembg returned empty mask",
  "started_at": "2024-06-10T15:31:00+03:00",
  "finished_at": "2024-06-10T15:31:01+03:00",
  "error": "rembg returned empty mask"
}
```

---

## 3. **Markdown-шаблон файла с инструкциями для Cursor**

```markdown
# Инструкция для разработки AI-системы обработки изображений товаров WooCommerce

## Общие принципы и требования

- Соблюдать модульность, обратную совместимость и простоту поддержки.
- Все изменения должны быть откатываемы, логироваться, снабжаться тестами и описанием.
- Строго придерживаться стандартов кодирования WordPress и Python.
- Использовать исключительно внутренние директории плагина в uploads/ai_image/.
- Каждый этап пайплайна (создание задания, обработка, выдача результата) должен быть прозрачно логирован и легко мониториться.
- Любые ошибки и сбои фиксируются и не блокируют выполнение других задач.

## Структура директорий

```

wp-content/
└── uploads/
└── ai\_image/
├── tasks/           # Задания на обработку
├── results/         # Готовые результаты
├── originals/       # Оригиналы изображений
├── processed/       # Финальные картинки
├── temp/            # Временные файлы
├── templates/       # Фоновые шаблоны
├── logos/           # Логотипы компании
├── logs/            # Логи работы
├── archive/         # Старые задания и результаты
├── config/          # Конфиги и параметры
└── readme.md        # Техническая документация

````

## Пример задания (tasks/)

```json
{
  "task_id": "20240610T153000_abc12345",
  "type": "tyre",
  "original_image": "originals/tyre_123456.png",
  "template": "templates/tyre_template_v2.png",
  "logo": "logos/company_logo.png",
  "product_data": {
    "brand": "Michelin",
    "model": "X-Ice North 4",
    "width": "205",
    "height": "55",
    "diameter": "R16",
    "load_index": "94",
    "speed_index": "T",
    "season": "зима",
    "studded": true
  },
  "output_filename": "processed/tyre_123456_ai.png",
  "created_at": "2024-06-10T15:30:00+03:00"
}
````

## Пример результата (results/)

```json
{
  "task_id": "20240610T153000_abc12345",
  "status": "success",
  "output_image": "processed/tyre_123456_ai.png",
  "log": "logs/20240610T153000_abc12345.log",
  "message": "OK",
  "started_at": "2024-06-10T15:31:00+03:00",
  "finished_at": "2024-06-10T15:31:20+03:00",
  "error": null
}
```

**В случае ошибки:**

```json
{
  "task_id": "20240610T153000_abc12345",
  "status": "error",
  "output_image": null,
  "log": "logs/20240610T153000_abc12345.log",
  "message": "Ошибка обработки изображения: rembg returned empty mask",
  "started_at": "2024-06-10T15:31:00+03:00",
  "finished_at": "2024-06-10T15:31:01+03:00",
  "error": "rembg returned empty mask"
}
```

## Требования к коду

* WordPress-плагин реализуется по WP Coding Standards (отступы, имена, безопасность, документирование).
* Python-скрипты в виртуальном окружении, зависимости фиксируются в requirements.txt, параметры в config.yaml.
* Для взаимодействия между WP и Python используется только файловый обмен (tasks/results), никаких внешних API.
* Все процессы должны быть документированы, протестированы, снабжены откатами и мониторингом.

## Цель проекта

Автоматизированная система массовой AI-обработки и генерации шаблонных изображений товаров для WooCommerce, реализованная через связку WP-плагина и Python-скриптов с прозрачной очередью задач и системой логирования.

---

**Этот документ копировать и вставлять в начало каждого нового проекта в Cursor, где участвует автоматизация AI-обработки изображений для WooCommerce.**

```

---

Если нужна отдельная версия на английском или адаптация под специфическую структуру серверов — скажи, подправлю.  
Готов расписать рекомендации по правам доступа к папкам или дать примеры bash-скриптов для автоматической чистки/архивации!
```


вопрос:
напиши структуру плагина

ответ:
Вот структура **плагина WordPress/WooCommerce** для автоматизации AI-обработки изображений по заданному пайплайну.
Структура полностью соответствует стандартам WordPress, включает все ключевые компоненты, поддерживает файловый обмен с Python-скриптами и масштабируемость.

---

## **1. Файловая структура плагина**

```plaintext
wp-content/
└── plugins/
    └── ai-product-image/
        ├── ai-product-image.php           # Главный файл плагина (точка входа)
        ├── readme.txt                     # Краткое описание, требования, changelog
        ├── includes/
        │   ├── class-task-manager.php     # Класс: создание и контроль задач (очередь)
        │   ├── class-image-replacer.php   # Класс: подмена изображений товаров
        │   ├── class-settings.php         # Класс: настройки плагина (UI + хранение)
        │   ├── class-logger.php           # Класс: логирование (файл/БД)
        │   ├── class-cron.php             # Класс: интеграция с cron/шедулером
        │   ├── helpers.php                # Вспомогательные функции
        │   └── constants.php              # Константы (пути, версии, префиксы)
        ├── admin/
        │   ├── admin-page.php             # UI страницы управления (выбор товаров, запуск обработки)
        │   ├── admin-list-table.php       # Класс: отображение списка задач (WP List Table)
        │   └── admin-logs.php             # UI для просмотра логов
        ├── assets/
        │   ├── css/
        │   │   └── admin-style.css        # Стили для админки
        │   └── js/
        │       └── admin-scripts.js       # Скрипты для интерфейса
        ├── languages/
        │   └── ai-product-image-ru_RU.po  # Переводы
        ├── uninstall.php                  # Безопасное удаление: чистка опций, файлов, логов
        └── README.md                      # Документация для разработчиков и админов
```

---

## **2. Краткое назначение файлов/папок**

* **ai-product-image.php** — основной файл плагина с заголовком, регистрацией хуков, автозагрузкой классов и инициализацией всех компонентов.
* **includes/** — бизнес-логика, менеджеры задач, обработка изображений, логирование, настройки, интеграция с cron.
* **admin/** — всё, что касается интерфейса администратора: страницы управления, таблицы задач, просмотр логов, обработка действий из UI.
* **assets/** — стили и JS только для админки.
* **languages/** — локализация для многоязычности.
* **uninstall.php** — полный и чистый откат плагина, удаление опций, логов и т.д.
* **README.md** — инструкция по установке, обновлению, поддержке.

---

## **3. Важные моменты архитектуры**

* Все временные/рабочие файлы (tasks, results, processed и т.д.) лежат только в `wp-content/uploads/ai_image/`.
* Все классы и функции имеют префикс `ai_product_image_` (например, класс `AI_Product_Image_Task_Manager`).
* Используются стандартные механизмы WordPress:

  * **WP\_List\_Table** — для интерфейса очереди задач
  * **wp\_schedule\_event** — для планирования обработки
  * **get\_option/update\_option** — для настроек
  * **wp\_update\_attachment\_metadata** — для замены изображений товаров
* Обработка очереди может запускаться как по кнопке, так и по cron (опционально через системный cron).
* Поддерживается пошаговая обработка (batch), чтобы не превышать лимиты по памяти/времени выполнения.
* Логи действий и ошибок доступны через отдельную страницу в админке.

---

## **4. Взаимодействие с Python**

* Папки и формат очереди/результатов описаны выше.
* Плагин:

  * Создаёт task-файлы в `uploads/ai_image/tasks/`
  * Проверяет наличие и статус результатов в `uploads/ai_image/results/`
  * После успешной обработки — подменяет изображение товара, чистит временные файлы, архивирует задания.

---

## **5. Пример структуры папок внутри uploads/ai\_image/**

> Эта папка создаётся и поддерживается плагином автоматически:

```plaintext
wp-content/uploads/ai_image/
├── tasks/
├── results/
├── originals/
├── processed/
├── temp/
├── templates/
├── logos/
├── logs/
├── archive/
├── config/
└── readme.md
```

---

## **6. Порядок инициализации (основные файлы)**

1. **ai-product-image.php**

   * Проверка зависимости WooCommerce.
   * Подключение autoload всех классов.
   * Регистрация хуков и активации cron.
   * Регистрация admin menu.

2. **class-settings.php**

   * Регистрация страницы настроек (пути, параметры обработки, батчи, шаблоны, логотипы).
   * Сохранение и валидация опций.

3. **class-task-manager.php**

   * Генерация задания на обработку, контроль статусов, работа с файловой очередью.

4. **class-cron.php**

   * Планирование регулярной обработки очереди, обработка batch’ами, уведомления.

5. **class-image-replacer.php**

   * Замена изображений товаров, откат/восстановление оригиналов при необходимости.

6. **class-logger.php**

   * Унифицированное логирование, просмотр логов через админку.

7. **admin-page.php**

   * Страница админки: просмотр очереди, запуск задач, ручной откат, мониторинг.

---

## **7. Расширяемость**

* Любой новый тип шаблона, параметров, локации — через папку templates/ и конфиги.
* Весь бизнес-алгоритм отделён от интерфейса, легко переносить на другой проект/сайт.
* Возможность замены файлового обмена на REST API (при переходе на VPS).

---

Если нужна структура файлов классов с примером заголовков или описание точек входа для API — могу расписать отдельно.
Если хочешь получить типовой код-заготовку для ai-product-image.php с автозагрузкой классов — скажи, подготовлю!